#include <stdio.h> // 駒の文字(先手:X 後手:O)

// 'X'と'O'という駒を管理している
char koma[2] = {'X', 'O'};

// 盤表示関数
// 実は仮引数(char board[])はchar *boardと解釈され、配列の長さの情報は失われてしまう
void print_board(char board[])
{
  printf("%c|%c|%c\n", board[0], board[1], board[2]);
  printf("%c|%c|%c\n", board[3], board[4], board[5]);
  printf("%c|%c|%c\n", board[6], board[7], board[8]);
  // printfで盤面をコンソールに出力している
  // "%c"はフォーマット指定子で文字を指定、"\n"は改行コード
}

// 置けるかチェック関数
// 戻り値が0 -> 駒が置けない
// 戻り値が1 -> 駒が置ける
int check(char board[], char x)
{
  int i;

  // 入力した文字の範囲判定をしています
  // C言語の文字は実は数字と同じです
  // 例えば'a'は97,'i'は 105,'x'は120と同じです
  // アルファベットのa~xは97~120の数字と対応しているというわけです
  // なので数字の範囲と同じように
  // if文でa~iの範囲外が入力されたときの判定を行っているということですね
  if (x < 'a' || 'i' < x)
  {
    // a~iの範囲外の文字が入力されるとreturn 0で結果を返している(駒が置けない)
    return 0;
  }

  // 文字は数字と同じなので数字のように足し算引き算ができます
  // iが配列のindex番号と対応していて↓のif文で使われますね
  // xはa~iのどれかなので'a'を引くことで0~8の値になります
  i = x - 'a'; // 'a'～'z' //0～8に変換(配列の添え字と対応している）

  // すでに置かれているか判定
  if (board[i] != x)
  {
    // 駒が置かれていたら0を返して結果を返している(駒が置けない)
    return 0;
  }

  // ここまで様々な判定を潜り抜けて1を返すことで駒が置けることを返している
  return 1;
}

// メイン関数。プログラムはここをエントリーポイントとして始まる
int main(void)
{
  // char型を要素として長さ9の配列を宣言し、a~iで初期化している
  // board[]が3目並べの盤面になる
  char board[9] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'};

  // xを宣言し、'a'で初期化している
  // ユーザーからの入力(盤面の位置)
  char x = 'a';

  // ターン数を管理している
  int turn;

  // 手番(XかOか)を管理している
  int teban;

  // 駒が置かれたかどうかを判定するための変数
  int ok;

  printf("三目並べを始めます。\n");

  // 9回繰り返し
  // 9回駒が置かれるまでループする
  for (turn = 0; turn < 9; turn++)
  {

    // % 2でturnが奇数か偶数かがわかる。tebanには1か0が入る
    // 0 -> 偶数, 1 -> 奇数
    // 手番は奇数か偶数かで管理している
    teban = turn % 2;

    // 置けるマスを入力するまで繰り返し
    ok = 0;
    while (ok == 0)
    {
      print_board(board); // 盤表示
      // 置く場所入力
      printf("どこに%cをいれますか?\n", koma[teban]);
      printf("a～iで指定してください。\n");

      // 入力データをクリア(scanfで[Enter]を読んでしまう問題を回避)
      rewind(stdin); 

      // ユーザーから入力をxに格納
      scanf("%c", &x);

      // 置く判定
      if (check(board, x))
      {
        //駒が置けるならwhile(ok == 0)のループから抜ける
        ok = 1;
      }
    }

    // 置く処理
    // x - 'a'でboardのindexが計算できる
    board[x - 'a'] = koma[teban];
  }

  // プログラムが終了
  return 0;
}
